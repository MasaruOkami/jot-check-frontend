<!doctype html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>åŸææ–™ãƒ©ãƒ™ãƒ« ã‹ã‚“ãŸã‚“ãƒã‚§ãƒƒã‚¯</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- LIFF v2 SDK -->
  <script src="https://static.line-scdn.net/liff/edge/2/sdk.js"></script>
  <!-- Supabase JS SDKï¼ˆãƒ–ãƒ©ã‚¦ã‚¶ç”¨ UMDï¼‰ -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", Arial, "Noto Sans JP", sans-serif;
      margin: 0;
      padding: 16px;
      background: #f7f7f7;
    }
    .container {
      max-width: 480px;
      margin: 0 auto;
    }
    h1 {
      font-size: 20px;
      margin: 0 0 8px;
    }
    .sub-title {
      font-size: 13px;
      color: #666;
      margin-bottom: 16px;
    }
    .card {
      background: #fff;
      border-radius: 12px;
      padding: 16px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.08);
      margin-bottom: 16px;
    }
    .note {
      font-size: 12px;
      color: #666;
      margin-top: 8px;
    }

    /* æ’®å½±ãƒœã‚¿ãƒ³ï¼ˆinput[type=file] ã‚’å†…åŒ…ã™ã‚‹ labelï¼‰ */
    .file-button {
      display: block;
      width: 100%;
      text-align: center;
      padding: 12px 16px;
      border-radius: 999px;
      border: none;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      background: #06c755;
      color: #fff;
      position: relative;
      overflow: hidden;
      box-sizing: border-box;
      margin-top: 8px;
    }
    .file-button input[type="file"] {
      position: absolute;
      inset: 0;
      opacity: 0;
      cursor: pointer;
    }

    img.preview {
      max-width: 100%;
      border-radius: 8px;
      margin-top: 12px;
      border: 1px solid #eee;
    }
    .status-text {
      font-size: 12px;
      color: #888;
      margin-top: 8px;
    }
    .processing {
      font-size: 12px;
      color: #0066cc;
      margin-top: 8px;
    }
    .result-title {
      margin-top: 16px;
      font-size: 13px;
      font-weight: 600;
    }
    .result-box {
      font-size: 12px;
      background: #fafafa;
      border-radius: 8px;
      padding: 8px;
      border: 1px solid #eee;
      white-space: pre-wrap;
      word-break: break-word;
      margin-top: 4px;
      max-height: 200px;
      overflow-y: auto;
    }
    .btn-sub {
      width: 100%;
      padding: 10px 16px;
      border-radius: 999px;
      border: none;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      background: #e0e0e0;
      color: #333;
      margin-top: 12px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>åŸææ–™ãƒ©ãƒ™ãƒ« ã‹ã‚“ãŸã‚“ãƒã‚§ãƒƒã‚¯</h1>
    <p class="sub-title">
      åŸææ–™åãŒå†™ã£ãŸå†™çœŸã‚’1æšé€ã‚‹ã ã‘ã§ã€ã‹ã‚“ãŸã‚“ã«ãƒã‚§ãƒƒã‚¯ã§ãã¾ã™ã€‚
    </p>

    <div class="card">
      <p class="note">
        ã¾ãšã¯ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ã€Œå•†å“åï¼ˆè¡¨é¢ï¼‰ã€ãŒå¤§ããå†™ã‚‹ã‚ˆã†ã«æ’®å½±ã—ã¦ãã ã•ã„ã€‚<br />
        èª­ã¿è¾¼ã¿ã€œè§£æã¾ã§ <b>5ã€œ10ç§’ã»ã©</b> ã‹ã‹ã‚Šã¾ã™ã€‚
      </p>

      <!-- æ’®å½±ãƒœã‚¿ãƒ³ï¼ˆã‚¿ãƒƒãƒ—ã§ã‚«ãƒ¡ãƒ© or ç”»åƒé¸æŠï¼‰ -->
      <label class="file-button">
        ğŸ“¸ æ’®å½±ã—ã¦è§£æã‚’é–‹å§‹ã™ã‚‹
        <input
          type="file"
          id="imageInput"
          accept="image/*"
          capture="environment"
        />
      </label>

      <p id="imageInfo" class="status-text">
        ã¾ã ç”»åƒãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚
      </p>

      <!-- æ’®å½±ã—ãŸç”»åƒã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ -->
      <img id="previewImage" class="preview" style="display:none;" alt="preview" />

      <!-- ã€Œ5ã€œ10ç§’ãŠå¾…ã¡ãã ã•ã„ã€è¡¨ç¤º -->
      <p id="processingText" class="processing" style="display:none;">
        èª­ã¿è¾¼ã¿ã€œè§£æã¾ã§ 5ã€œ10ç§’ã»ã©ã‹ã‹ã‚Šã¾ã™ã€‚å°‘ã—ã ã‘ãŠå¾…ã¡ãã ã•ã„â€¦
      </p>

      <!-- OCR çµæœï¼ˆç”»é¢ä¸‹éƒ¨ï¼‰ -->
      <div id="ocrResultWrapper" style="display:none;">
        <p class="result-title">èª­ã¿å–ã£ãŸå†…å®¹</p>
        <pre id="ocrResult" class="result-box"></pre>
      </div>

      <!-- â˜…è¿½åŠ : front ç”¨ã®å•†å“åç¢ºèªãƒ–ãƒ­ãƒƒã‚¯ -->
      <div id="titleConfirmWrapper" style="display:none; margin-top:12px;">
        <p class="result-title">å•†å“åã®ç¢ºèª</p>
        <input
          id="titleInput"
          type="text"
          placeholder="å•†å“åã‚’ç¢ºèªãƒ»ä¿®æ­£ã—ã¦ãã ã•ã„"
          style="width:100%; box-sizing:border-box; padding:8px 10px; border-radius:8px; border:1px solid #ccc; font-size:13px; margin-bottom:8px;"
        />
        <button id="confirmTitleBtn" class="btn-sub">
          ã“ã®å•†å“åã§è£é¢ã‚’æ’®å½±ã™ã‚‹
        </button>
        <p class="note" id="titleHint" style="margin-top:6px;"></p>
      </div>
      <!-- â˜…è¿½åŠ ã“ã“ã¾ã§ -->

      <button id="restartBtn" class="btn-sub" style="display:none;">
        åˆ¥ã®å†™çœŸã§ã‚‚ã†ä¸€åº¦ãŸã‚ã™
      </button>
      
      <pre id="dbg"
        style="background:#111;color:#0f0;padding:10px;border-radius:8px;max-height:220px;overflow:auto;font-size:12px;margin-top:12px;">
      </pre>
    </div>
  </div>

  <script>
    const DBG_ID = "dbg";
    function dbg(...args) {
      console.log(...args);
      const el = document.getElementById(DBG_ID);
      if (!el) return;
      const line = args
        .map((a) => {
          try {
            return typeof a === "string" ? a : JSON.stringify(a);
          } catch {
            return String(a);
          }
        })
        .join(" ");
      el.textContent += line + "\n";
    }

    const HTML_VERSION = "2026-01-29-front-back-flow"; // â˜…å¤‰æ›´: ãƒãƒ¼ã‚¸ãƒ§ãƒ³æ›´æ–°
  
    const LIFF_ID = "2008945507-FfPO1rgZ";
  
    const SUPABASE_URL = "https://isslaklpblhqagwtrgfi.supabase.co";
    const SUPABASE_ANON_KEY =
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imlzc2xha2xwYmxocWFnd3RyZ2ZpIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjMwOTQ3OTgsImV4cCI6MjA3ODY3MDc5OH0.d1Ehg8jDjFVtC2eejGH2RGlnTDax95f8EBifJ9ZYuO8";
  
    // Supabase Functions ã® URL
    const AUTH_LINE_URL =
      "https://isslaklpblhqagwtrgfi.functions.supabase.co/auth-line";
    const OCR_FUNCTION_URL =
      "https://isslaklpblhqagwtrgfi.functions.supabase.co/ocr-check";
  
    const supabase = window.supabase.createClient(
      SUPABASE_URL,
      SUPABASE_ANON_KEY,
    );

    // â˜…è¿½åŠ : front/back ãƒ•ãƒ­ãƒ¼ç”¨ã®çŠ¶æ…‹
    let currentStep = "front";          // "front" -> "back"
    let confirmedProductTitle = null;   // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒç¢ºèªã—ãŸå•†å“å
    let frontImagePath = null;         // Storage ä¸Šã® front ç”»åƒãƒ‘ã‚¹
  
    function showFatal(msg) {
      document.body.innerHTML = `
        <div style="padding:16px; font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Arial, 'Noto Sans JP', sans-serif;">
          <h2 style="margin:0 0 8px;">èªè¨¼ã‚¨ãƒ©ãƒ¼</h2>
          <pre style="white-space:pre-wrap; word-break:break-word; background:#f5f5f5; padding:12px; border-radius:8px;">${msg}</pre>
        </div>
      `;
    }
  
    async function main() {
      dbg("HTML VERSION:", HTML_VERSION);
      dbg("AUTH_LINE_URL:", AUTH_LINE_URL);

      const imageInput = document.getElementById("imageInput");
      const imageInfoEl = document.getElementById("imageInfo");
      const previewImageEl = document.getElementById("previewImage");
      const processingText = document.getElementById("processingText");
      const ocrResultWrap = document.getElementById("ocrResultWrapper");
      const ocrResultEl = document.getElementById("ocrResult");
      const restartBtn = document.getElementById("restartBtn");

      // å•†å“åç¢ºèª UI
      const titleConfirmWrapper = document.getElementById("titleConfirmWrapper");
      const titleInput = document.getElementById("titleInput");
      const confirmTitleBtn = document.getElementById("confirmTitleBtn");
      const titleHintEl = document.getElementById("titleHint");
  
      // âœ… èªè¨¼å®Œäº†ã™ã‚‹ã¾ã§æ’®å½±ã§ããªã„
      imageInput.disabled = true;
      imageInfoEl.textContent = "èªè¨¼ä¸­ã§ã™â€¦ï¼ˆæ•°ç§’ãŠå¾…ã¡ãã ã•ã„ï¼‰";
  
      // ãƒªã‚»ãƒƒãƒˆ
      restartBtn.onclick = () => {
        imageInput.value = "";
        imageInfoEl.textContent = "ã¾ã ç”»åƒãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚";
        previewImageEl.style.display = "none";
        processingText.style.display = "none";
        ocrResultWrap.style.display = "none";
        restartBtn.style.display = "none";
        titleConfirmWrapper.style.display = "none";
        titleInput.value = "";
        titleHintEl.textContent = "";
        currentStep = "front";
        confirmedProductTitle = null;
        frontImagePath = null;
      };
  
      dbg("HTML VERSION:", HTML_VERSION);
      dbg("AUTH_LINE_URL:", AUTH_LINE_URL);
      
      // â˜…æœ€é‡è¦ï¼šã¾ãšGETã§å©ã„ã¦ç–é€šç¢ºèª
      try {
        const ping = await fetch(AUTH_LINE_URL, { method: "GET" });
        dbg("PING status:", ping.status);
        dbg("PING text:", (await ping.text()).slice(0, 200));
      } catch (e) {
        dbg("PING fetch failed:", String(e));
        showFatal("PING fetch failed: " + String(e));
        return;
      }

      // â‘  LIFF init
      await liff.init({ liffId: LIFF_ID });
  
      // â‘¡ æœªãƒ­ã‚°ã‚¤ãƒ³ãªã‚‰ãƒ­ã‚°ã‚¤ãƒ³
      if (!liff.isLoggedIn()) {
        console.log("LIFF not logged in -> login()");
        liff.login();
        return;
      }
  
      // â‘¢ LINE token & friendFlag
      const idToken = liff.getIDToken();
      const { friendFlag } = await liff.getFriendship();
  
      console.log("STEP4 about to call auth-line:", AUTH_LINE_URL);
      console.log(
        "idToken head:",
        String(idToken || "").slice(0, 12),
        "friendFlag:",
        friendFlag,
      );
  
      // â‘£ auth-line å‘¼ã³å‡ºã—
      let authRes;
      try {
        authRes = await fetch(AUTH_LINE_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ idToken, friendFlag }),
        });
      } catch (e) {
        console.error("âŒ auth-line fetch failed", e);
        showFatal("auth-line fetch failed (network/CORS): " + String(e));
        return;
      }
  
      const authText = await authRes.text();
      console.log("âœ… auth-line status:", authRes.status);
      console.log("âœ… auth-line raw:", authText.slice(0, 500));
  
      if (!authRes.ok) {
        showFatal(
          "auth-line error: status=" +
            authRes.status +
            "\n" +
            authText.slice(0, 800),
        );
        return;
      }
  
      let session;
      try {
        session = JSON.parse(authText);
      } catch {
        showFatal(
          "auth-line response is not JSON:\n" + authText.slice(0, 800),
        );
        return;
      }
  
      if (!session?.access_token || !session?.refresh_token) {
        showFatal(
          "auth-line JSON ok but missing tokens:\n" +
            JSON.stringify(session, null, 2),
        );
        return;
      }
  
      // â‘¤ Supabase ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’ã‚»ãƒƒãƒˆ
      await supabase.auth.setSession({
        access_token: session.access_token,
        refresh_token: session.refresh_token,
      });
  
      const { data: check, error: checkErr } = await supabase.auth.getSession();
      console.log("ğŸ§ª Supabase session after setSession", check, checkErr);
  
      if (!check?.session?.access_token) {
        showFatal(
          "setSession done but getSession has no access_token.\nerr=" +
            String(checkErr),
        );
        return;
      }
  
      // JWT payload ãƒã‚§ãƒƒã‚¯
      const payload = JSON.parse(
        atob(check.session.access_token.split(".")[1]),
      );
      console.log("ğŸ§ª access_token payload", payload);
  
      if (!payload?.sub || payload?.role === "anon") {
        showFatal(
          "Supabase session JWT is not authenticated.\n" +
            JSON.stringify(payload, null, 2),
        );
        return;
      }
  
      // â‘¥ èªè¨¼æˆåŠŸ â†’ æ’®å½±ã‚¢ãƒ³ãƒ­ãƒƒã‚¯
      imageInput.disabled = false;
      imageInfoEl.textContent =
        "èªè¨¼OKã€‚ã¾ãšã¯ã€å•†å“åï¼ˆè¡¨é¢ï¼‰ã€ãŒå†™ã£ãŸå†™çœŸã‚’æ’®å½±ã—ã¦ãã ã•ã„ã€‚";
      console.log("âœ… LINE auth & Supabase auth completed.");
  
      // LINE userIdï¼ˆä¿å­˜ãƒ‘ã‚¹ç”¨ï¼‰
      const profile = await liff.getProfile();
      const lineUserId = profile.userId;
  
      // ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠå¾Œã®å‡¦ç†ï¼ˆfront/back ã§åˆ†å²ï¼‰
      imageInput.addEventListener("change", async (event) => {
        const file = event.target.files[0];
        if (!file) return;
  
        const sizeKb = Math.round(file.size / 1024);
        imageInfoEl.textContent =
          "é¸æŠã•ã‚ŒãŸç”»åƒ: " +
          file.name +
          "ï¼ˆç´„ " +
          sizeKb +
          " KBï¼‰";
  
        const blobUrl = URL.createObjectURL(file);
        previewImageEl.src = blobUrl;
        previewImageEl.style.display = "block";
  
        ocrResultWrap.style.display = "none";
        ocrResultEl.textContent = "";
        titleConfirmWrapper.style.display = "none";
        titleHintEl.textContent = "";
        restartBtn.style.display = "none";
        processingText.style.display = "block";
  
        try {
          // Storage upload
          const filePath =
            lineUserId + "/" + Date.now().toString() + "-" + file.name;
  
          const { data, error } = await supabase.storage
            .from("ocr-images")
            .upload(filePath, file);
          if (error || !data) {
            throw new Error(
              "upload failed: " +
                (error?.message || JSON.stringify(error)),
            );
          }
  
          const uploadedPath = data.path;
  
          // ocr-check å‘¼ã³å‡ºã—å‰ã« access_token å–å¾—
          const { data: sess } = await supabase.auth.getSession();
          const accessToken = sess?.session?.access_token;
          console.log(
            "[before ocr-check] access head",
            String(accessToken || "").slice(0, 20),
          );
  
          if (!accessToken) throw new Error("no access_token before ocr-check");
  
          if (currentStep === "front") {
            // ---- STEP1: frontï¼ˆå•†å“åæ¨å®š + ç¢ºèªï¼‰ ----
            const res = await fetch(OCR_FUNCTION_URL, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: "Bearer " + accessToken,
              },
              body: JSON.stringify({
                imagePath: uploadedPath,
                scan_side: "front",
                mode: "ocr_only", // ç”»é¢ä¸Šã§ç¢ºèªã™ã‚‹ã ã‘
              }),
            });
  
            const j = await res.json().catch(() => ({}));
            console.log("ocr-check(front) response", j);
  
            processingText.style.display = "none";
            restartBtn.style.display = "block";
  
            if (!res.ok || !j.ok) {
              ocrResultEl.textContent =
                "frontè§£æã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚\nstatus=" +
                res.status +
                "\n" +
                (j.error || JSON.stringify(j, null, 2));
              ocrResultWrap.style.display = "block";
              return;
            }
  
            const autoTitle = j.product_title || "";
            const candidates = Array.isArray(j.title_candidates)
              ? j.title_candidates
              : [];
  
            let text = "";
            text +=
              "æ¨å®šã•ã‚ŒãŸå•†å“åï¼ˆfrontï¼‰: " +
              (autoTitle || "ï¼ˆæœªå–å¾—ï¼‰") +
              "\n\n";
            if (candidates.length > 0) {
              text += "å€™è£œ:\n";
              text += candidates
                .map((c) => "- " + (c.text || JSON.stringify(c)))
                .join("\n");
              text += "\n\n";
            }
            text += j.ocr_text_excerpt || "";
  
            ocrResultEl.textContent =
              text || "frontè§£æçµæœãŒå–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚";
            ocrResultWrap.style.display = "block";
  
            // å•†å“åå…¥åŠ›æ¬„ã¨ã€Œè£é¢ã¸é€²ã‚€ã€ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
            titleInput.value = autoTitle;
            titleHintEl.textContent =
              "å•†å“åãŒé•ã†å ´åˆã¯ä¿®æ­£ã—ã¦ã‹ã‚‰ã€Œã“ã®å•†å“åã§è£é¢ã‚’æ’®å½±ã™ã‚‹ã€ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚";
            titleConfirmWrapper.style.display = "block";
  
            // ç¢ºå®šæ™‚ã®å‡¦ç†
            confirmTitleBtn.onclick = () => {
              const v = titleInput.value.trim();
              confirmedProductTitle = v || autoTitle || null;
              if (!confirmedProductTitle) {
                alert("å•†å“åãŒç©ºã§ã™ã€‚å°‘ãªãã¨ã‚‚1æ–‡å­—å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚");
                return;
              }
              frontImagePath = uploadedPath;
              currentStep = "back";
              titleConfirmWrapper.style.display = "none";
              imageInfoEl.textContent =
                "å•†å“åã‚’ç¢ºå®šã—ã¾ã—ãŸã€‚æ¬¡ã«ã€åŸææ–™åï¼ˆè£é¢ï¼‰ã€ãŒå†™ã£ãŸå†™çœŸã‚’æ’®å½±ã—ã¦ãã ã•ã„ã€‚";
              dbg("CONFIRMED_TITLE", confirmedProductTitle);
            };
          } else {
            // ---- STEP2: backï¼ˆæœ€çµ‚è§£æ + reply-line é€šçŸ¥ï¼‰----
            if (!confirmedProductTitle) {
              alert("å…ˆã« front ã§å•†å“åã‚’ç¢ºå®šã—ã¦ãã ã•ã„ã€‚");
              processingText.style.display = "none";
              return;
            }
  
            const res = await fetch(OCR_FUNCTION_URL, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: "Bearer " + accessToken,
              },
              body: JSON.stringify({
                imagePath: uploadedPath,
                front_image_path: frontImagePath || null,
                scan_side: "back",
                mode: "final", // æœ€çµ‚è§£æ + LINE é€šçŸ¥
                product_title: confirmedProductTitle,
              }),
            });
  
            const j = await res.json().catch(() => ({}));
            console.log("ocr-check(back) response", j);
  
            processingText.style.display = "none";
            restartBtn.style.display = "block";
  
            if (!res.ok || !j.ok) {
              ocrResultEl.textContent =
                "backè§£æã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚\nstatus=" +
                res.status +
                "\n" +
                (j.error || JSON.stringify(j, null, 2));
              ocrResultWrap.style.display = "block";
              return;
            }
  
            let text = "";
            if (j.reply_text) {
              text += j.reply_text + "\n\n";
            }
            if (j.ingredients_text) {
              text += "åŸææ–™ãƒ†ã‚­ã‚¹ãƒˆ:\n" + j.ingredients_text + "\n\n";
            } else if (j.ocr_text_excerpt) {
              text += "OCRæŠœç²‹:\n" + j.ocr_text_excerpt + "\n\n";
            }
            text += "è§£æçµæœã¯LINEãƒˆãƒ¼ã‚¯ç”»é¢ã«ã‚‚é€ä¿¡ã•ã‚Œã¦ã„ã¾ã™ã€‚";
  
            ocrResultEl.textContent = text;
            ocrResultWrap.style.display = "block";
  
            // 1ã‚µã‚¤ã‚¯ãƒ«å®Œäº† â†’ æ¬¡ã¯ã¾ãŸfrontã‹ã‚‰
            currentStep = "front";
            confirmedProductTitle = null;
            frontImagePath = null;
            imageInfoEl.textContent =
              "è§£æãŒå®Œäº†ã—ã¾ã—ãŸã€‚åˆ¥ã®å•†å“ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹å ´åˆã¯ã€å†åº¦ã€å•†å“åï¼ˆè¡¨é¢ï¼‰ã€ã®å†™çœŸã‹ã‚‰æ’®å½±ã—ã¦ãã ã•ã„ã€‚";
          }
        } catch (e) {
          console.error("ocr-check flow error", e);
          processingText.style.display = "none";
          ocrResultEl.textContent = "ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: " + String(e);
          ocrResultWrap.style.display = "block";
          restartBtn.style.display = "block";
        }
      });
    }
  
    main().catch((e) => {
      console.error("fatal", e);
      showFatal("fatal error: " + String(e));
    });
  </script>
</body>
</html>
